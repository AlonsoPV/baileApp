require File.join(File.dirname(`node --print "require.resolve('expo/package.json')"`), "scripts/autolinking")
require File.join(File.dirname(`node --print "require.resolve('react-native/package.json')"`), "scripts/react_native_pods")

require 'json'
require 'open3'
require 'pathname'
podfile_properties = JSON.parse(File.read(File.join(__dir__, 'Podfile.properties.json'))) rescue {}

def ccache_enabled?(podfile_properties)
  # Environment variable takes precedence
  return ENV['USE_CCACHE'] == '1' if ENV['USE_CCACHE']
  
  # Fall back to Podfile properties
  podfile_properties['apple.ccacheEnabled'] == 'true'
end

ENV['RCT_NEW_ARCH_ENABLED'] ||= '0' if podfile_properties['newArchEnabled'] == 'false'
ENV['EX_DEV_CLIENT_NETWORK_INSPECTOR'] ||= podfile_properties['EX_DEV_CLIENT_NETWORK_INSPECTOR']
ENV['RCT_USE_RN_DEP'] ||= '1' if podfile_properties['ios.buildReactNativeFromSource'] != 'true' && podfile_properties['newArchEnabled'] != 'false'
ENV['RCT_USE_PREBUILT_RNCORE'] ||= '1' if podfile_properties['ios.buildReactNativeFromSource'] != 'true' && podfile_properties['newArchEnabled'] != 'false'
platform :ios, podfile_properties['ios.deploymentTarget'] || '15.1'

prepare_react_native_project!

target 'DondeBailarMX' do
  use_expo_modules!

  # ✅ Fix: Especificar SocketRocket directamente para evitar problemas de CDN en Xcode Cloud
  # SocketRocket es una dependencia de React Native y puede fallar al descargar desde jsdelivr
  pod 'SocketRocket', '~> 0.7.1'

  # ✅ Native Google Sign-In SDK (in-app; no Safari browser)
  pod 'GoogleSignIn'

  if ENV['EXPO_USE_COMMUNITY_AUTOLINKING'] == '1'
    config_command = ['node', '-e', "process.argv=['', '', 'config'];require('@react-native-community/cli').run()"];
  else
    config_command = [
      'npx',
      'expo-modules-autolinking',
      'react-native-config',
      '--json',
      '--platform',
      'ios'
    ]
  end

  config = use_native_modules!(config_command)

  # Ensure CocoaPods/RN scripts always use the *real* React Native path in this repo.
  # This prevents Archive failures where generated scripts reference a stale pnpm folder
  # (e.g. react-native@..._@babel+core@X...) that no longer exists after dependency updates.
  begin
    rn_pkg_json, _ = Open3.capture2("node", "-p", "require.resolve('react-native/package.json')")
    rn_path_abs = File.dirname(rn_pkg_json.strip)
    # Prefer a stable symlinked path (doesn't encode peer dependency versions like pnpm store folders do)
    rn_stable_rel = "../node_modules/react-native"
    rn_stable_abs = File.expand_path(rn_stable_rel, __dir__)

    rn_path_rel =
      if File.exist?(File.join(rn_stable_abs, "package.json"))
        rn_stable_rel
      else
        Pathname.new(rn_path_abs).relative_path_from(Pathname.new(__dir__)).to_s
      end

    if rn_path_rel && !rn_path_rel.empty?
      # RN CocoaPods helpers expect a path relative to the ios/ directory.
      ENV["REACT_NATIVE_PATH"] = rn_path_rel
      # Also align the path we pass into use_react_native!/react_native_post_install
      config[:reactNativePath] = rn_path_rel if config.is_a?(Hash)
      puts "[Podfile] REACT_NATIVE_PATH=#{rn_path_rel} (resolvedAbs=#{File.expand_path(rn_path_rel, __dir__)})"
    end
  rescue => e
    puts "[Podfile] WARN: failed to resolve react-native path via node: #{e}"
  end

  use_frameworks! :linkage => podfile_properties['ios.useFrameworks'].to_sym if podfile_properties['ios.useFrameworks']
  use_frameworks! :linkage => ENV['USE_FRAMEWORKS'].to_sym if ENV['USE_FRAMEWORKS']

  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => podfile_properties['expo.jsEngine'] == nil || podfile_properties['expo.jsEngine'] == 'hermes',
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/..",
    :privacy_file_aggregation_enabled => podfile_properties['apple.privacyManifestAggregationEnabled'] != 'false',
  )

  post_install do |installer|
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      :ccache_enabled => ccache_enabled?(podfile_properties),
    )

    # pnpm can encode peer deps into the folder name under node_modules/.pnpm, and some generated
    # script phases hardcode that path. When peer deps change (e.g. @babel/core patch bump),
    # Archive can fail with:
    #   react-native/scripts/xcode/with-environment.sh: No such file or directory
    #
    # Force script phases to reference the stable symlinked path: ../node_modules/react-native
    begin
      stable_rn_dir = "$RCT_SCRIPT_POD_INSTALLATION_ROOT/../node_modules/react-native"
      installer.pods_project.targets.each do |t|
        t.build_phases.each do |phase|
          next unless phase.respond_to?(:shell_script) && phase.shell_script
          next unless phase.shell_script.include?("node_modules/.pnpm/react-native@")

          phase.shell_script = phase.shell_script
            .gsub(%r{\$RCT_SCRIPT_POD_INSTALLATION_ROOT/\.\./node_modules/\.pnpm/react-native@[^/]+/node_modules/react-native}, stable_rn_dir)
            .gsub(%r{\.\./node_modules/\.pnpm/react-native@[^/]+/node_modules/react-native}, "../node_modules/react-native")
        end
      end
      installer.pods_project.save
      puts "[Podfile] Patched Pods script phases to use stable react-native path"
    rescue => e
      puts "[Podfile] WARN: failed to patch Pods script phases: #{e}"
    end

    # ✅ CRÍTICO: Parchear scripts de CocoaPods que usan Node para asegurar NODE_BINARY dinámico
    # Los scripts generados por hermes-engine, React-runtimescheduler, React-rendererdebug,
    # React-runtimeexecutor y otros pods pueden tener:
    # 1. Paths hardcodeados como /opt/homebrew/Cellar/node/25.5.0/bin/node (no existen en Xcode Cloud)
    # 2. Referencias a NODE_BINARY sin asegurar que esté definido
    # 3. Scripts que fallan silenciosamente si Node no está disponible
    # Esto causa fallos silenciosos: "never received target ended message"
    # Solución: Agregar loader de .xcode.env a TODOS los scripts que usan Node (detección más amplia)
    begin
      xcode_env_loader = <<~SCRIPT
        # Load .xcode.env to get NODE_BINARY dynamically (required for Xcode Cloud)
        if [[ -f "$PODS_ROOT/../.xcode.env" ]]; then
          source "$PODS_ROOT/../.xcode.env"
        fi
        if [[ -z "${NODE_BINARY:-}" ]]; then
          export NODE_BINARY=$(command -v node)
        fi
        if [[ -z "${NODE_BINARY:-}" ]]; then
          echo "ERROR: NODE_BINARY not found. Ensure Node.js is installed and in PATH."
          exit 1
        fi
      SCRIPT

      patched_count = 0
      installer.pods_project.targets.each do |t|
        t.build_phases.each do |phase|
          next unless phase.respond_to?(:shell_script) && phase.shell_script
          
          script = phase.shell_script
          original_script = script.dup
          
          # Detección conservadora: solo buscar paths hardcodeados o referencias explícitas a NODE_BINARY
          # NO intentar detectar uso genérico de 'node' para evitar falsos positivos
          has_hardcoded_path = script.match?(%r{/opt/homebrew/Cellar/node/[\d.]+/bin/node|/usr/local/Cellar/node/[\d.]+/bin/node|/usr/local/bin/node|/opt/homebrew/bin/node})
          uses_node_binary = script.match?(/\bNODE_BINARY\b/)
          has_xcode_env = script.match?(/\.xcode\.env/)
          
          # Solo parchear si hay paths hardcodeados O si el script ya usa NODE_BINARY pero no carga .xcode.env
          if has_hardcoded_path || (uses_node_binary && !has_xcode_env)
            # 1. Reemplazar paths hardcodeados de Node con NODE_BINARY dinámico
            script = script.gsub(%r{/opt/homebrew/Cellar/node/[\d.]+/bin/node}, '${NODE_BINARY:-$(command -v node)}')
            script = script.gsub(%r{/usr/local/Cellar/node/[\d.]+/bin/node}, '${NODE_BINARY:-$(command -v node)}')
            script = script.gsub(%r{/usr/local/bin/node}, '${NODE_BINARY:-$(command -v node)}')
            script = script.gsub(%r{/opt/homebrew/bin/node}, '${NODE_BINARY:-$(command -v node)}')
            
            # 2. Agregar el loader de .xcode.env al inicio si no está presente
            # Verificar múltiples formas de que el loader ya esté presente
            has_loader = script.include?(".xcode.env") || 
                        script.match?(/source.*\.xcode\.env/) ||
                        script.match?(/if.*-f.*\.xcode\.env/)
            
            unless has_loader
              script = xcode_env_loader + "\n" + script
            end
            
            if script != original_script
              phase.shell_script = script
              patched_count += 1
              puts "[Podfile] Patched Node path in #{t.name} build phase"
            end
          end
        end
      end
      
      if patched_count > 0
        installer.pods_project.save
        puts "[Podfile] Patched #{patched_count} Pods script(s) to use dynamic NODE_BINARY"
      else
        puts "[Podfile] No Pods scripts needed Node path patching"
      end
    rescue => e
      puts "[Podfile] WARN: failed to patch Node paths in Pods scripts: #{e}"
      puts "[Podfile] Error details: #{e.backtrace.first(3).join("\n")}"
    end

    # ✅ Force C++17 + libc++ for Hermes / React Native pods (fixes HermesExecutorFactory errors)
    # These errors typically happen when some pods/targets compile with an older C++ dialect.
    cxx_lang = 'gnu++20'
    cxx_lib  = 'libc++'

    # Pods project (all pod targets)
    installer.pods_project.targets.each do |t|
      t.build_configurations.each do |config|
        config.build_settings['CLANG_CXX_LANGUAGE_STANDARD'] = cxx_lang
        config.build_settings['CLANG_CXX_LIBRARY'] = cxx_lib
        config.build_settings['GCC_ENABLE_CPP_EXCEPTIONS'] = 'YES'
        config.build_settings['GCC_ENABLE_CPP_RTTI'] = 'YES'
        # Optional belt-and-suspenders: enforce via flags if any pod overrides the dialect.
        config.build_settings['OTHER_CPLUSPLUSFLAGS'] ||= ['$(inherited)']
        flags = config.build_settings['OTHER_CPLUSPLUSFLAGS']
        flags = [flags] if flags.is_a?(String)
        # Ensure we use C++20 consistently (some pods override the dialect).
        flags.reject! { |f| f.start_with?('-std=') } if flags.respond_to?(:reject!)
        flags << '-std=c++20'
        config.build_settings['OTHER_CPLUSPLUSFLAGS'] = flags
      end
    end

    # User project(s) (app target + any aggregate targets that expose user_project)
    if installer.respond_to?(:aggregate_targets)
      installer.aggregate_targets.each do |aggregate|
        user_project = aggregate.user_project
        next unless user_project
        targets =
          if user_project.respond_to?(:native_targets)
            user_project.native_targets
          else
            user_project.targets
          end

        targets.each do |t|
          t.build_configurations.each do |config|
            config.build_settings['CLANG_CXX_LANGUAGE_STANDARD'] = cxx_lang
            config.build_settings['CLANG_CXX_LIBRARY'] = cxx_lib
            config.build_settings['GCC_ENABLE_CPP_EXCEPTIONS'] = 'YES'
            config.build_settings['GCC_ENABLE_CPP_RTTI'] = 'YES'
            config.build_settings['OTHER_CPLUSPLUSFLAGS'] ||= ['$(inherited)']
            flags = config.build_settings['OTHER_CPLUSPLUSFLAGS']
            flags = [flags] if flags.is_a?(String)
            flags.reject! { |f| f.start_with?('-std=') } if flags.respond_to?(:reject!)
            flags << '-std=c++20'
            config.build_settings['OTHER_CPLUSPLUSFLAGS'] = flags
          end
        end
        user_project.save
      end
    end
  end
end
